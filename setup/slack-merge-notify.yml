# Slack notification on merge to main, staging, or dev/* branches
# Waits for Vercel deployment to succeed (skipped for dev branches), then collects all commits,
# rephrases them in French for non-technical stakeholders via AI, and posts to Slack.
#
# Required secrets (already set for saship-digest):
#   AI_GATEWAY_API_KEY   — Vercel AI Gateway API key
#   SLACK_WEBHOOK_URL    — Slack incoming webhook

name: Slack Merge Notify

on:
  push:
    branches: [main, staging, 'dev/**']

permissions:
  contents: read
  deployments: read

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Wait for Vercel deployment
        id: vercel
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Skip Vercel wait for dev branches (no deployment)
          if echo "${GITHUB_REF_NAME}" | grep -q "^dev/"; then
            echo "Dev branch — skipping Vercel deployment check"
            echo "deploy_ok=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          SHA="${{ github.sha }}"
          echo "Waiting for Vercel deployment on $SHA..."

          MAX_WAIT=600  # 10 minutes
          INTERVAL=20
          ELAPSED=0

          while [ "$ELAPSED" -lt "$MAX_WAIT" ]; do
            # Check deployment statuses on this commit (Vercel creates these)
            STATUSES=$(gh api "/repos/${{ github.repository }}/deployments?sha=$SHA&per_page=5" 2>&1 || echo "[]")

            # Validate we got a JSON array (not an error string)
            if ! echo "$STATUSES" | jq 'type == "array"' 2>/dev/null | grep -q true; then
              echo "API returned non-array (${ELAPSED}s elapsed): $(echo "$STATUSES" | head -1)"
              sleep "$INTERVAL"
              ELAPSED=$((ELAPSED + INTERVAL))
              continue
            fi

            # Look for a Vercel deployment
            DEPLOY_ID=$(echo "$STATUSES" | jq -r '[.[] | select(.creator.login == "vercel[bot]" or .environment == "Production" or .environment == "Preview")] | first | .id // empty')

            if [ -n "$DEPLOY_ID" ]; then
              # Check the status of this deployment
              STATE=$(gh api "/repos/${{ github.repository }}/deployments/$DEPLOY_ID/statuses?per_page=1" 2>/dev/null \
                | jq -r '.[0].state // "pending"')

              echo "Deployment $DEPLOY_ID state: $STATE (${ELAPSED}s elapsed)"

              if [ "$STATE" = "success" ]; then
                echo "deploy_ok=true" >> "$GITHUB_OUTPUT"
                DEPLOY_URL=$(gh api "/repos/${{ github.repository }}/deployments/$DEPLOY_ID/statuses?per_page=1" \
                  | jq -r '.[0].environment_url // empty')
                echo "deploy_url=$DEPLOY_URL" >> "$GITHUB_OUTPUT"
                exit 0
              elif [ "$STATE" = "failure" ] || [ "$STATE" = "error" ]; then
                echo "::error::Vercel deployment failed"
                echo "deploy_ok=false" >> "$GITHUB_OUTPUT"
                exit 0
              fi
            else
              echo "No Vercel deployment found yet (${ELAPSED}s elapsed)"
            fi

            sleep "$INTERVAL"
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "::warning::Timed out waiting for Vercel deployment"
          echo "deploy_ok=timeout" >> "$GITHUB_OUTPUT"

      - name: Collect merge commits
        if: steps.vercel.outputs.deploy_ok == 'true'
        id: commits
        run: |
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.event.after }}"

          # If before is all zeros (new branch), just use the head commit
          if echo "$BEFORE" | grep -qE '^0+$'; then
            COMMITS=$(git log -1 --pretty=format:'%s' "$AFTER")
          else
            COMMITS=$(git log --pretty=format:'%s' "${BEFORE}..${AFTER}")
          fi

          if [ -z "$COMMITS" ]; then
            echo "no_commits=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "no_commits=false" >> "$GITHUB_OUTPUT"
          echo "commits<<EOF" >> "$GITHUB_OUTPUT"
          echo "$COMMITS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

          # Extract project name from commit prefix (e.g. [EOS] -> "EOS")
          PROJECT=$(echo "$COMMITS" | grep -oE '^\[([^]]+)\]' | head -1 | tr -d '[]')
          echo "project=${PROJECT}" >> "$GITHUB_OUTPUT"

      - name: Rephrase with AI
        if: steps.vercel.outputs.deploy_ok == 'true' && steps.commits.outputs.no_commits != 'true'
        id: ai
        env:
          AI_GATEWAY_API_KEY: ${{ secrets.AI_GATEWAY_API_KEY }}
          RAW_COMMITS: ${{ steps.commits.outputs.commits }}
        run: |
          BRANCH="${GITHUB_REF_NAME}"

          if [ "$BRANCH" = "main" ]; then
            ENV_LABEL="production"
          elif echo "$BRANCH" | grep -q "^dev/"; then
            ENV_LABEL="développement"
          else
            ENV_LABEL="staging (environnement de test)"
          fi

          cat > /tmp/prompt.txt <<PROMPT_EOF
          Tu rediges une mise a jour Slack detaillee pour des personnes non-techniques (fondateurs, chefs de projet, clients).

          De nouveaux changements viennent d'etre deployes en ${ENV_LABEL}. Voici les messages de commit bruts :

          ${RAW_COMMITS}

          Reecris-les sous forme d'une liste a puces detaillee (format Slack mrkdwn) comprehensible par une personne non-technique.
          Regles :
          - Ecris en francais
          - Utilise un langage simple : ce qui a change pour l'utilisateur ou le produit, pas comment c'est code
          - Aucun jargon technique (pas de "refactor", "fix lint", "bump deps", "merge branch", "CI", etc.)
          - Explique TOUS les changements, meme techniques — traduis-les en impact concret (ex: "fix lint" → "Correction de problemes de qualite de code", "update CI" → "Mise a jour du systeme de deploiement automatique")
          - Chaque puce commence par •
          - Pour mettre en gras utilise *simple asterisques* (format Slack mrkdwn), JAMAIS **double asterisques** (Markdown standard)
          - Donne suffisamment de detail pour que le lecteur comprenne ce qui a change et pourquoi c'est utile, 1-2 phrases par puce
          - N'inclus aucun lien ni URL

          Reponds avec UNIQUEMENT la liste a puces. Pas d'introduction, pas de conclusion.
          PROMPT_EOF

          jq -n --rawfile content /tmp/prompt.txt \
            '{model:"anthropic/claude-haiku-4-5",max_tokens:512,messages:[{role:"user",content:$content}]}' \
            > /tmp/ai_request.json

          HTTP_CODE=$(curl -s -o /tmp/ai_response.json -w "%{http_code}" \
            https://ai-gateway.vercel.sh/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $AI_GATEWAY_API_KEY" \
            -d @/tmp/ai_request.json)

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::warning::AI Gateway returned HTTP $HTTP_CODE — falling back to raw commits"
            echo "fallback=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          SUMMARY=$(jq -r '.choices[0].message.content' /tmp/ai_response.json)

          # Fix AI sometimes using **double asterisks** (Markdown) instead of *single* (Slack mrkdwn)
          SUMMARY=$(echo "$SUMMARY" | sed 's/\*\*\([^*]*\)\*\*/\*\1\*/g')

          echo "fallback=false" >> "$GITHUB_OUTPUT"
          echo "summary<<EOF" >> "$GITHUB_OUTPUT"
          echo "$SUMMARY" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Post success to Slack
        if: steps.vercel.outputs.deploy_ok == 'true' && steps.commits.outputs.no_commits != 'true'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          RAW_COMMITS: ${{ steps.commits.outputs.commits }}
          AI_SUMMARY: ${{ steps.ai.outputs.summary }}
          AI_FALLBACK: ${{ steps.ai.outputs.fallback }}
        run: |
          BRANCH="${GITHUB_REF_NAME}"

          if [ "$AI_FALLBACK" = "true" ]; then
            BODY=$(echo "$RAW_COMMITS" | sed 's/^/• /')
          else
            BODY="$AI_SUMMARY"
          fi

          AUTHOR="${{ github.event.head_commit.author.name }}"
          PROJECT="${{ steps.commits.outputs.project }}"
          # Build label: "EOS " or "" if no prefix detected
          if [ -n "$PROJECT" ]; then
            PROJ_LABEL="${PROJECT} "
          else
            PROJ_LABEL=""
          fi

          if [ "$BRANCH" = "main" ]; then
            {
              echo "*Mise en production ${PROJ_LABEL}effectuee* :rocket:"
              echo ""
              echo "$BODY"
            } > /tmp/slack_text.txt
          elif echo "$BRANCH" | grep -q "^dev/"; then
            {
              echo ":hammer_and_wrench: *${AUTHOR} a ajouté à l'environnement de développement ${PROJ_LABEL}*"
              echo ""
              echo "$BODY"
            } > /tmp/slack_text.txt
          else
            {
              echo "*Nouveau deploiement ${PROJ_LABEL}en staging* :construction:"
              echo ""
              echo "$BODY"
              echo ""
              echo "En attente de validation pour passer en production :point_up:"
            } > /tmp/slack_text.txt
          fi

          jq -n --rawfile text /tmp/slack_text.txt '{text: $text}' > /tmp/slack_payload.json
          curl -s -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d @/tmp/slack_payload.json

